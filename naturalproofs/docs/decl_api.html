<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>decl_api API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>decl_api</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This module defines the API to declare variables and functions in the UCT fragment.

import z3
from naturalproofs.uct import UCTSort, is_expr_fg_sort
from naturalproofs.AnnotatedContext import AnnotatedContext, default_annctx


# Functions to create declarations
def Const(name, uct_sort, annctx=default_annctx):
    &#34;&#34;&#34;
    Declare a constant with the given name and uct sort.  
    :param name: string  
    :param uct_sort: naturalproofs.uct.UCTSort  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: z3.ExprRef  
    &#34;&#34;&#34;
    if not isinstance(uct_sort, UCTSort):
        raise TypeError(&#39;UCTSort expected.&#39;)
    z3const = z3.Const(name, uct_sort.z3sort)
    if not isinstance(annctx, AnnotatedContext):
        raise TypeError(&#39;AnnotatedContext expected.&#39;)
    # The constant must be tracked as a 0-arity function
    declaration = z3const.decl()
    annctx.add_alias_annotation(declaration, tuple([uct_sort]))
    annctx.add_vocabulary_annotation(declaration)
    return z3const


def Consts(names, uct_sort, annctx=default_annctx):
    &#34;&#34;&#34;
    Declare a list of constants.  
    :param names: string containing all the names separated by a space  
    :param uct_sort: naturalproofs.uct.UCTSort  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: list of z3.ExprRef  
    &#34;&#34;&#34;
    if not isinstance(uct_sort, UCTSort):
        raise TypeError(&#39;UCTSort expected.&#39;)
    z3consts = z3.Consts(names, uct_sort.z3sort)
    if not isinstance(annctx, AnnotatedContext):
        raise TypeError(&#39;AnnotatedContext expected.&#39;)
    for z3const in z3consts:
        # Constants must be tracked as a 0-arity function
        declaration = z3const.decl()
        annctx.add_alias_annotation(declaration, tuple([uct_sort]))
        annctx.add_vocabulary_annotation(declaration)
    return z3consts


def Function(name, *uct_signature, annctx=default_annctx):
    &#34;&#34;&#34;
    Declare an uninterpreted function symbol. The signature is given as input-sort, input-sort...output-sort  
    :param name: string  
    :param uct_signature: tuple of naturalproofs.uct.UCTSort  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: z3.FuncDeclRef  
    &#34;&#34;&#34;
    if not all([isinstance(sig, UCTSort) for sig in uct_signature]):
        raise TypeError(&#39;UCTSort expected.&#39;)
    if not isinstance(annctx, AnnotatedContext):
        raise TypeError(&#39;AnnotatedContext expected.&#39;)
    if len(uct_signature) &lt; 2:
        raise ValueError(&#39;There must be atleast one input sort and exactly one output sort.&#39;)
    z3sig = [sig.z3sort for sig in uct_signature]
    z3func = z3.Function(name, *z3sig)
    annctx.add_alias_annotation(z3func, uct_signature)
    annctx.add_vocabulary_annotation(z3func)
    return z3func


def RecFunction(name, *uct_signature, annctx=default_annctx):
    &#34;&#34;&#34;
    Declare a recursively defined function symbol.  
    :param name: string  
    :param uct_signature: tuple of naturalproofs.uct.UCTSort  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: z3.FuncDeclRef  
    &#34;&#34;&#34;
    # Currently defaults to calling Function as recursive functions are not tracked in a separate way.
    return Function(name, *uct_signature, annctx=annctx)


def AddRecDefinition(recdef, formal_params, body, annctx=default_annctx):
    &#34;&#34;&#34;
    Add a definition to a recursive function symbol. The function symbol must be declared and tracked before a definiiton
    can be added.  
    The definition is given in terms of a tuple of formal parameters that are themselves declared constants, and the body
    is a z3.ExprRef object constructed from these constants and other declared/built-in functions.  
    :param recdef: z3.FuncDeclRef  
    :param formal_params: tuple of z3.ExprRef (currently only z3.ArithRef)  
    :param body: z3.ExprRef  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: None
    &#34;&#34;&#34;
    if not isinstance(formal_params, tuple) and isinstance(formal_params, z3.ExprRef):
        # Only one formal parameter
        formal_params = (formal_params,)
    if not annctx.is_tracked_vocabulary(recdef):
        raise ValueError(&#39;Function symbol must be declared using naturalproofs.decl_api.Function&#39;)
    if len(formal_params) != recdef.arity():
        raise ValueError(&#39;Number of formal parameters does not match arity of function symbol.&#39;)
    # Check that all formal parameters are of the foreground sort.
    # Arguments of other sorts are not supported.
    elif not all([is_expr_fg_sort(param, annctx) for param in formal_params]):
        raise TypeError(&#39;All formal parameters can only be of the foreground sort.&#39;)
    if not isinstance(body, z3.ExprRef):
        raise TypeError(&#39;ExprRef expected.&#39;)
    # TODO: check that the definition is of the supported form: positive recursive mentions, for example.
    annctx.add_recdef_annotation((recdef, formal_params, body))


def AddAxiom(formal_params, body, annctx=default_annctx):
    &#34;&#34;&#34;
    Add an axiom with respect to which the reasoning must be performed.  
    The axiom is given in terms of a tuple of formal parameters that are themselves declared constants, and the body
    is a z3.ExprRef object constructed from these constants and other declared/built-in functions. If the axiom does not
    take any parameters, the first argument is ().  
    :param formal_params: tuple of z3.ExprRef (currently only z3.ArithRef)  
    :param body: z3.ExprRef  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: None  
    &#34;&#34;&#34;
    if not isinstance(formal_params, tuple) and isinstance(formal_params, z3.ExprRef):
        # Only one formal parameter
        formal_params = (formal_params,)
    # Check that all formal parameters are of the foreground sort.
    # Arguments of other sorts are not supported.
    if not all([is_expr_fg_sort(param, annctx) for param in formal_params]):
        raise TypeError(&#39;All formal parameters can only be of the foreground sort.&#39;)
    if not isinstance(body, z3.ExprRef):
        raise TypeError(&#39;ExprRef expected.&#39;)
    annctx.add_axiom_annotation((formal_params, body))


# Utility functions to manipulate declarations
def get_vocabulary(annctx=default_annctx):
    &#34;&#34;&#34;
    Returns the set of all the declarations tracked by annctx  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: set of z3.FuncDeclRef  
    &#34;&#34;&#34;
    return annctx.get_vocabulary_annotation()


def get_uct_signature(funcdeclref, annctx=default_annctx):
    &#34;&#34;&#34;
    Returns the uct signature of the given function if tracked by annctx.
    :param funcdeclref: z3.FuncDeclRef
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext
    :return: tuple of naturalproofs.uct.UCTSort or None
    &#34;&#34;&#34;
    return annctx.read_alias_annotation(funcdeclref)


def get_decl_from_name(declname, annctx=default_annctx):
    &#34;&#34;&#34;
    Returns the declaration whose name is declname if it is tracked by annctx.  
    :param declname: string  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: z3.FuncDeclRef or None  
    &#34;&#34;&#34;
    vocabulary = get_vocabulary(annctx)
    return next((decl for decl in vocabulary if decl.name() == declname), None)


def get_recursive_definition(recdef, alldefs=False, annctx=default_annctx):
    &#34;&#34;&#34;
    Looks up the definition of the function symbol from the set of recursive definitions in the annctx context.
    Returns None if no definition exists in the context.  
    If the second argument is true, then all recursive definitions are returned.  
    :param recdef: z3.FuncDeclRef  
    :param alldefs: bool  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: (recdef, tuple of z3.ExprRef, z3.ExprRef), or a set of such triples, or None  
    &#34;&#34;&#34;
    recdef_set = annctx.get_recdef_annotation()
    if alldefs:
        return recdef_set
    else:
        if not annctx.is_tracked_vocabulary(recdef):
            raise ValueError(&#39;Function symbol must be declared using naturalproofs.decl_api.Function&#39;)
        return next((definition for definition in recdef_set if recdef == definition[0]), None)


def get_all_axioms(annctx=default_annctx):
    &#34;&#34;&#34;
    Returns all axioms tracked by annctx.  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: (tuple of z3.ExprRef, z3.ExprRef)  
    &#34;&#34;&#34;
    return annctx.get_axiom_annotation()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="decl_api.AddAxiom"><code class="name flex">
<span>def <span class="ident">AddAxiom</span></span>(<span>formal_params, body, annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an axiom with respect to which the reasoning must be performed.<br>
The axiom is given in terms of a tuple of formal parameters that are themselves declared constants, and the body
is a z3.ExprRef object constructed from these constants and other declared/built-in functions. If the axiom does not
take any parameters, the first argument is ().<br>
:param formal_params: tuple of z3.ExprRef (currently only z3.ArithRef)<br>
:param body: z3.ExprRef<br>
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext<br>
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddAxiom(formal_params, body, annctx=default_annctx):
    &#34;&#34;&#34;
    Add an axiom with respect to which the reasoning must be performed.  
    The axiom is given in terms of a tuple of formal parameters that are themselves declared constants, and the body
    is a z3.ExprRef object constructed from these constants and other declared/built-in functions. If the axiom does not
    take any parameters, the first argument is ().  
    :param formal_params: tuple of z3.ExprRef (currently only z3.ArithRef)  
    :param body: z3.ExprRef  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: None  
    &#34;&#34;&#34;
    if not isinstance(formal_params, tuple) and isinstance(formal_params, z3.ExprRef):
        # Only one formal parameter
        formal_params = (formal_params,)
    # Check that all formal parameters are of the foreground sort.
    # Arguments of other sorts are not supported.
    if not all([is_expr_fg_sort(param, annctx) for param in formal_params]):
        raise TypeError(&#39;All formal parameters can only be of the foreground sort.&#39;)
    if not isinstance(body, z3.ExprRef):
        raise TypeError(&#39;ExprRef expected.&#39;)
    annctx.add_axiom_annotation((formal_params, body))</code></pre>
</details>
</dd>
<dt id="decl_api.AddRecDefinition"><code class="name flex">
<span>def <span class="ident">AddRecDefinition</span></span>(<span>recdef, formal_params, body, annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a definition to a recursive function symbol. The function symbol must be declared and tracked before a definiiton
can be added.<br>
The definition is given in terms of a tuple of formal parameters that are themselves declared constants, and the body
is a z3.ExprRef object constructed from these constants and other declared/built-in functions.<br>
:param recdef: z3.FuncDeclRef<br>
:param formal_params: tuple of z3.ExprRef (currently only z3.ArithRef)<br>
:param body: z3.ExprRef<br>
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext<br>
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def AddRecDefinition(recdef, formal_params, body, annctx=default_annctx):
    &#34;&#34;&#34;
    Add a definition to a recursive function symbol. The function symbol must be declared and tracked before a definiiton
    can be added.  
    The definition is given in terms of a tuple of formal parameters that are themselves declared constants, and the body
    is a z3.ExprRef object constructed from these constants and other declared/built-in functions.  
    :param recdef: z3.FuncDeclRef  
    :param formal_params: tuple of z3.ExprRef (currently only z3.ArithRef)  
    :param body: z3.ExprRef  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: None
    &#34;&#34;&#34;
    if not isinstance(formal_params, tuple) and isinstance(formal_params, z3.ExprRef):
        # Only one formal parameter
        formal_params = (formal_params,)
    if not annctx.is_tracked_vocabulary(recdef):
        raise ValueError(&#39;Function symbol must be declared using naturalproofs.decl_api.Function&#39;)
    if len(formal_params) != recdef.arity():
        raise ValueError(&#39;Number of formal parameters does not match arity of function symbol.&#39;)
    # Check that all formal parameters are of the foreground sort.
    # Arguments of other sorts are not supported.
    elif not all([is_expr_fg_sort(param, annctx) for param in formal_params]):
        raise TypeError(&#39;All formal parameters can only be of the foreground sort.&#39;)
    if not isinstance(body, z3.ExprRef):
        raise TypeError(&#39;ExprRef expected.&#39;)
    # TODO: check that the definition is of the supported form: positive recursive mentions, for example.
    annctx.add_recdef_annotation((recdef, formal_params, body))</code></pre>
</details>
</dd>
<dt id="decl_api.Const"><code class="name flex">
<span>def <span class="ident">Const</span></span>(<span>name, uct_sort, annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Declare a constant with the given name and uct sort.<br>
:param name: string<br>
:param uct_sort: naturalproofs.uct.UCTSort<br>
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext<br>
:return: z3.ExprRef</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Const(name, uct_sort, annctx=default_annctx):
    &#34;&#34;&#34;
    Declare a constant with the given name and uct sort.  
    :param name: string  
    :param uct_sort: naturalproofs.uct.UCTSort  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: z3.ExprRef  
    &#34;&#34;&#34;
    if not isinstance(uct_sort, UCTSort):
        raise TypeError(&#39;UCTSort expected.&#39;)
    z3const = z3.Const(name, uct_sort.z3sort)
    if not isinstance(annctx, AnnotatedContext):
        raise TypeError(&#39;AnnotatedContext expected.&#39;)
    # The constant must be tracked as a 0-arity function
    declaration = z3const.decl()
    annctx.add_alias_annotation(declaration, tuple([uct_sort]))
    annctx.add_vocabulary_annotation(declaration)
    return z3const</code></pre>
</details>
</dd>
<dt id="decl_api.Consts"><code class="name flex">
<span>def <span class="ident">Consts</span></span>(<span>names, uct_sort, annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Declare a list of constants.<br>
:param names: string containing all the names separated by a space<br>
:param uct_sort: naturalproofs.uct.UCTSort<br>
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext<br>
:return: list of z3.ExprRef</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Consts(names, uct_sort, annctx=default_annctx):
    &#34;&#34;&#34;
    Declare a list of constants.  
    :param names: string containing all the names separated by a space  
    :param uct_sort: naturalproofs.uct.UCTSort  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: list of z3.ExprRef  
    &#34;&#34;&#34;
    if not isinstance(uct_sort, UCTSort):
        raise TypeError(&#39;UCTSort expected.&#39;)
    z3consts = z3.Consts(names, uct_sort.z3sort)
    if not isinstance(annctx, AnnotatedContext):
        raise TypeError(&#39;AnnotatedContext expected.&#39;)
    for z3const in z3consts:
        # Constants must be tracked as a 0-arity function
        declaration = z3const.decl()
        annctx.add_alias_annotation(declaration, tuple([uct_sort]))
        annctx.add_vocabulary_annotation(declaration)
    return z3consts</code></pre>
</details>
</dd>
<dt id="decl_api.Function"><code class="name flex">
<span>def <span class="ident">Function</span></span>(<span>name, *uct_signature, annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Declare an uninterpreted function symbol. The signature is given as input-sort, input-sort&hellip;output-sort<br>
:param name: string<br>
:param uct_signature: tuple of naturalproofs.uct.UCTSort<br>
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext<br>
:return: z3.FuncDeclRef</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Function(name, *uct_signature, annctx=default_annctx):
    &#34;&#34;&#34;
    Declare an uninterpreted function symbol. The signature is given as input-sort, input-sort...output-sort  
    :param name: string  
    :param uct_signature: tuple of naturalproofs.uct.UCTSort  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: z3.FuncDeclRef  
    &#34;&#34;&#34;
    if not all([isinstance(sig, UCTSort) for sig in uct_signature]):
        raise TypeError(&#39;UCTSort expected.&#39;)
    if not isinstance(annctx, AnnotatedContext):
        raise TypeError(&#39;AnnotatedContext expected.&#39;)
    if len(uct_signature) &lt; 2:
        raise ValueError(&#39;There must be atleast one input sort and exactly one output sort.&#39;)
    z3sig = [sig.z3sort for sig in uct_signature]
    z3func = z3.Function(name, *z3sig)
    annctx.add_alias_annotation(z3func, uct_signature)
    annctx.add_vocabulary_annotation(z3func)
    return z3func</code></pre>
</details>
</dd>
<dt id="decl_api.RecFunction"><code class="name flex">
<span>def <span class="ident">RecFunction</span></span>(<span>name, *uct_signature, annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Declare a recursively defined function symbol.<br>
:param name: string<br>
:param uct_signature: tuple of naturalproofs.uct.UCTSort<br>
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext<br>
:return: z3.FuncDeclRef</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RecFunction(name, *uct_signature, annctx=default_annctx):
    &#34;&#34;&#34;
    Declare a recursively defined function symbol.  
    :param name: string  
    :param uct_signature: tuple of naturalproofs.uct.UCTSort  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: z3.FuncDeclRef  
    &#34;&#34;&#34;
    # Currently defaults to calling Function as recursive functions are not tracked in a separate way.
    return Function(name, *uct_signature, annctx=annctx)</code></pre>
</details>
</dd>
<dt id="decl_api.get_all_axioms"><code class="name flex">
<span>def <span class="ident">get_all_axioms</span></span>(<span>annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all axioms tracked by annctx.<br>
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext<br>
:return: (tuple of z3.ExprRef, z3.ExprRef)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_all_axioms(annctx=default_annctx):
    &#34;&#34;&#34;
    Returns all axioms tracked by annctx.  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: (tuple of z3.ExprRef, z3.ExprRef)  
    &#34;&#34;&#34;
    return annctx.get_axiom_annotation()</code></pre>
</details>
</dd>
<dt id="decl_api.get_decl_from_name"><code class="name flex">
<span>def <span class="ident">get_decl_from_name</span></span>(<span>declname, annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the declaration whose name is declname if it is tracked by annctx.<br>
:param declname: string<br>
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext<br>
:return: z3.FuncDeclRef or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_decl_from_name(declname, annctx=default_annctx):
    &#34;&#34;&#34;
    Returns the declaration whose name is declname if it is tracked by annctx.  
    :param declname: string  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: z3.FuncDeclRef or None  
    &#34;&#34;&#34;
    vocabulary = get_vocabulary(annctx)
    return next((decl for decl in vocabulary if decl.name() == declname), None)</code></pre>
</details>
</dd>
<dt id="decl_api.get_recursive_definition"><code class="name flex">
<span>def <span class="ident">get_recursive_definition</span></span>(<span>recdef, alldefs=False, annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Looks up the definition of the function symbol from the set of recursive definitions in the annctx context.
Returns None if no definition exists in the context.<br>
If the second argument is true, then all recursive definitions are returned.<br>
:param recdef: z3.FuncDeclRef<br>
:param alldefs: bool<br>
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext<br>
:return: (recdef, tuple of z3.ExprRef, z3.ExprRef), or a set of such triples, or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_recursive_definition(recdef, alldefs=False, annctx=default_annctx):
    &#34;&#34;&#34;
    Looks up the definition of the function symbol from the set of recursive definitions in the annctx context.
    Returns None if no definition exists in the context.  
    If the second argument is true, then all recursive definitions are returned.  
    :param recdef: z3.FuncDeclRef  
    :param alldefs: bool  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: (recdef, tuple of z3.ExprRef, z3.ExprRef), or a set of such triples, or None  
    &#34;&#34;&#34;
    recdef_set = annctx.get_recdef_annotation()
    if alldefs:
        return recdef_set
    else:
        if not annctx.is_tracked_vocabulary(recdef):
            raise ValueError(&#39;Function symbol must be declared using naturalproofs.decl_api.Function&#39;)
        return next((definition for definition in recdef_set if recdef == definition[0]), None)</code></pre>
</details>
</dd>
<dt id="decl_api.get_uct_signature"><code class="name flex">
<span>def <span class="ident">get_uct_signature</span></span>(<span>funcdeclref, annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the uct signature of the given function if tracked by annctx.
:param funcdeclref: z3.FuncDeclRef
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext
:return: tuple of naturalproofs.uct.UCTSort or None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_uct_signature(funcdeclref, annctx=default_annctx):
    &#34;&#34;&#34;
    Returns the uct signature of the given function if tracked by annctx.
    :param funcdeclref: z3.FuncDeclRef
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext
    :return: tuple of naturalproofs.uct.UCTSort or None
    &#34;&#34;&#34;
    return annctx.read_alias_annotation(funcdeclref)</code></pre>
</details>
</dd>
<dt id="decl_api.get_vocabulary"><code class="name flex">
<span>def <span class="ident">get_vocabulary</span></span>(<span>annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the set of all the declarations tracked by annctx<br>
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext<br>
:return: set of z3.FuncDeclRef</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vocabulary(annctx=default_annctx):
    &#34;&#34;&#34;
    Returns the set of all the declarations tracked by annctx  
    :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  
    :return: set of z3.FuncDeclRef  
    &#34;&#34;&#34;
    return annctx.get_vocabulary_annotation()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="decl_api.AddAxiom" href="#decl_api.AddAxiom">AddAxiom</a></code></li>
<li><code><a title="decl_api.AddRecDefinition" href="#decl_api.AddRecDefinition">AddRecDefinition</a></code></li>
<li><code><a title="decl_api.Const" href="#decl_api.Const">Const</a></code></li>
<li><code><a title="decl_api.Consts" href="#decl_api.Consts">Consts</a></code></li>
<li><code><a title="decl_api.Function" href="#decl_api.Function">Function</a></code></li>
<li><code><a title="decl_api.RecFunction" href="#decl_api.RecFunction">RecFunction</a></code></li>
<li><code><a title="decl_api.get_all_axioms" href="#decl_api.get_all_axioms">get_all_axioms</a></code></li>
<li><code><a title="decl_api.get_decl_from_name" href="#decl_api.get_decl_from_name">get_decl_from_name</a></code></li>
<li><code><a title="decl_api.get_recursive_definition" href="#decl_api.get_recursive_definition">get_recursive_definition</a></code></li>
<li><code><a title="decl_api.get_uct_signature" href="#decl_api.get_uct_signature">get_uct_signature</a></code></li>
<li><code><a title="decl_api.get_vocabulary" href="#decl_api.get_vocabulary">get_vocabulary</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>