<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>extensions.finitemodel API documentation</title>
<meta name="description" content="This module defines the class FiniteModel representing finite models extracted from smt models witnessing a proof
failure using the natural proofs â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>extensions.finitemodel</code></h1>
</header>
<section id="section-intro">
<p>This module defines the class FiniteModel representing finite models extracted from smt models witnessing a proof
failure using the natural proofs package.
</p>
<p>Explanation of object attributes:<br>
- Object attributes<br>
&ndash; finitemodel: the finite model extracted from an smt model.<br>
&ndash; smtmodel: the smt model that was used for extraction.<br>
&ndash; vocabulary: the vocabulary of constants and functions represented in the finite model.<br>
&ndash; annctx: the annotated context in which the foreground sort annotation is tracked.<br>
&ndash; offset: the 'offset' added to the foreground universe after extraction. Offset is initially 0. If at any point the
offset is not 0, then the value of any foreground term present in the finite model is its value as given by the smt
model, plus the offset.<br>
&mdash; fg_universe: the set of all foreground elements present in the finite model.<br>
- Logging attributes<br>
&ndash; extraction_terms: the terms used for finite model extraction at the time of creation.<br>
- Caching attributes<br>
&ndash; recompute_offset: whether the model is already offset from the true values in the smt model, or if future offset
computations must add to the current offset. Used for 'caching' offset models without needing further offsets unless
explicitly specified. Set to 'True' by default, so all offset computations will have an effect.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module defines the class FiniteModel representing finite models extracted from smt models witnessing a proof 
failure using the natural proofs package.  

Explanation of object attributes:  
- Object attributes  
-- finitemodel: the finite model extracted from an smt model.  
-- smtmodel: the smt model that was used for extraction.  
-- vocabulary: the vocabulary of constants and functions represented in the finite model.  
-- annctx: the annotated context in which the foreground sort annotation is tracked.  
-- offset: the &#39;offset&#39; added to the foreground universe after extraction. Offset is initially 0. If at any point the 
offset is not 0, then the value of any foreground term present in the finite model is its value as given by the smt 
 model, plus the offset.  
--- fg_universe: the set of all foreground elements present in the finite model.  
- Logging attributes  
-- extraction_terms: the terms used for finite model extraction at the time of creation.  
- Caching attributes  
-- recompute_offset: whether the model is already offset from the true values in the smt model, or if future offset 
computations must add to the current offset. Used for &#39;caching&#39; offset models without needing further offsets unless 
explicitly specified. Set to &#39;True&#39; by default, so all offset computations will have an effect.  
&#34;&#34;&#34;

import itertools
import z3
# model.compact should be turned off to not get lambdas, only actual arrays/sets.
z3.set_param(&#39;model.compact&#39;, False)

from naturalproofs.AnnotatedContext import default_annctx 
from naturalproofs.uct import fgsort, fgsetsort, intsort, intsetsort, boolsort
from naturalproofs.decl_api import get_vocabulary, get_uct_signature
from naturalproofs.extensions.finitemodel_utils import transform_fg_universe, collect_fg_universe


class FiniteModel:
    def __init__(self, smtmodel, terms, vocabulary=None, annctx=default_annctx):
        &#34;&#34;&#34;
        Finite model creation.  
        Foreground universe of extracted model corresponds to terms with subterm-closure. If vocabulary is not 
        specified, the entire vocabulary tracked in annctx is used.  
        :param smtmodel: z3.ModelRef  
        :param terms: set of z3.ExprRef  
        :param vocabulary: set of z3.ExprRef  
        :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  

        This function also defines the format of finite models.  
        Given a vocabulary of functions f1, f2, ..fm, of arity a1, a2, ...am, the model is as follows:  
        model :: dict {&#39;fk&#39; : dict_fk}  
        where &#39;fk&#39; is some representation of the function fk, and  
        dict_fk :: dict {(e1, e2,... ek) : fk(e1, e2, ...ek)}  
        where (e1, e2, ...ek) is a tuple such that e1, e2,.. etc are concrete values in python that are 
        dependent on the domain and range sorts of fk.  
        In particular if the arity k is 0, then dict_fk will be of the following form:  
        dict_fk :: dict {() : fk()}  

        These models are meant to be partial models, and in general it will not be possible to evaluate an arbitrary
        formula on such a model, just those that are quantifier-free with foreground terms in the set of terms used 
        to extract the finite model.  
        &#34;&#34;&#34;
        model = dict()
        # TODO: the assumption is that uninterpreted functions have arguments only from the foreground sort. Must handle
        #  cases where uninterpreted functions have arguments in other domains, primarily integers.
        # Subterm-close the given terms assuming one-way functions
        # TODO: checks for all terms being of the foreground sort.
        subterm_closure = _get_all_subterms(terms)
        elems = {smtmodel.eval(term, model_completion=True) for term in subterm_closure}
        if vocabulary is None:
            vocabulary = get_vocabulary(annctx)
        for func in vocabulary:
            arity = func.arity()
            *input_signature, output_sort = get_uct_signature(func, annctx)
            # Only supporting uninterpreted functions with input arguments all from the foreground sort
            if not all(sig == fgsort for sig in input_signature):
                raise ValueError(&#39;Function with input(s) not from the foreground sort. Unsupported.&#39;)
            func_key_repr = model_key_repr(func)
            # Distinguish common cases for faster execution
            if arity == 0:
                model[func_key_repr] = {(): _extract_value(smtmodel.eval(func(), model_completion=True), output_sort)}
            elif arity == 1:
                model[func_key_repr] = {
                    (_extract_value(elem, fgsort),): _extract_value(smtmodel.eval(func(elem), model_completion=True),
                                                                    output_sort) for elem in elems}
            else:
                func_dict = dict()
                args = itertools.product(elems, repeat=arity)
                for arg in args:
                    arg_value = tuple(_extract_value(component, fgsort) for component in arg)
                    func_dict[arg_value] = _extract_value(smtmodel.eval(func(*arg), model_completion=True), output_sort)
                model[func_key_repr] = func_dict
        # Object attributes
        self.finitemodel = model
        self.smtmodel = smtmodel
        self.vocabulary = vocabulary
        self.annctx = annctx
        self.offset = 0
        self.fg_universe = collect_fg_universe(self.finitemodel, self.annctx)
        # Logging attributes
        self.extraction_terms = subterm_closure
        # Caching attributes
        self.recompute_offset = True

    # Some common functions on finite models
    def get_fg_elements(self):
        # fg_elem_set = set()
        # _ = transform_fg_universe(finite_model, lambda x: (fg_elem_set.add(x), x)[1], annctx)
        # return fg_elem_set
        return self.fg_universe

    def add_fg_element_offset(self, offset_value):
        if self.recompute_offset:
            self.finitemodel = transform_fg_universe(self.finitemodel, lambda x: x + offset_value, self.annctx)
            self.offset = self.offset + offset_value
            self.fg_universe = {elem + offset_value for elem in self.fg_universe}


# Helper functions for extract_finite_model
# Representation of keys in the finite model top-level dictionary.
def model_key_repr(funcdeclref):
    # Should be equivalent to naturalproofs.AnnotatedContext._alias_annotation_key_repr(funcdeclref)
    # For z3.FuncDeclRef objects, this is almost always equal to name()
    return funcdeclref.name()


# Return all subterms of the given set of terms
def _get_all_subterms(terms):
    &#34;&#34;&#34;
    :param terms: set of z3.ExprRef
    :return: set of z3.ExprRef
    &#34;&#34;&#34;
    subterm_closure = set()
    for term in terms:
        subterm_closure.add(term)
        if term.decl().arity != 0:
            subterm_closure = subterm_closure | _get_all_subterms(set(term.children()))
    return subterm_closure


def _extract_value(value, uct_sort):
    &#34;&#34;&#34;
    Converts the value of a concrete constant represented as a z3.ExprRef into a simple python type
    that can be explicitly manipulated.  
    The explicit conversion scheme is as follows:  
    fgsort -&gt; int  
    fgsetsort -&gt; set of int  
    intsort -&gt; int  
    intsetsort -&gt; set of int  
    boolsort -&gt; bool  
    :param value: z3.ExprRef  
    :param uct_sort: uct.UCTSort  
    :return: any  
    &#34;&#34;&#34;
    # value assumed to be such that value.decl().arity == 0
    if uct_sort == boolsort:
        # value is either BoolVal(True) or BoolVal(False)
        return z3.is_true(value)
    elif uct_sort == fgsort or uct_sort == intsort:
        # value is an IntVal(v) for some number v
        return value.as_long()
    elif uct_sort == fgsetsort or uct_sort == intsetsort:
        # value is a set of integers.
        # model.compact has been disabled (see top of file). ArrayRef should not have lambdas in it.
        if not isinstance(value, z3.ArrayRef):
            raise ValueError(&#39;Something is wrong. Model is returning lambdas instead of arrays.&#39;)
        # iteratively deconstruct the expression to build the set of python numbers.
        extracted_set = set()
        value = value.__deepcopy__()
        while True:
            if z3.is_K(value):
                # Base case. Either full set or empty set.
                if z3.simplify(value[0]):
                    # Full set of integers. Raise exception.
                    raise ValueError(&#39;Model assigned infinite sets to some interpretations. Unsupported.&#39;)
                else:
                    return extracted_set
            elif z3.is_store(value):
                remaining_set, entry, if_belongs = value.childrne()
                value = remaining_set
                extracted_set = extracted_set | ({entry.as_long()} if z3.is_true(if_belongs) else {})
            else:
                raise ValueError(&#39;ArrayRef is constructed with neither Store nor K. Possible multidimensional arrays. &#39;
                                 &#39;Unsupported.&#39;) 
    else:
        raise ValueError(&#39;UCT Sort type not supported for extraction of models.&#39;)


def recover_value(value, uct_sort):
    &#34;&#34;&#34;
    Inverse of _extract_value. Given a pythonic value, returns a z3 embedding of it depending on its uct sort. The 
    explicit embedding scheme is as follows:
    fgsort -&gt; z3.ArithRef
    fgsetsort -&gt; z3.ArrayRef
    intsort -&gt; z3.ArithRef
    intsetsort -&gt; z3.ArrayRef
    boolsort -&gt; z3.BoolRef
    :param value: any
    :param uct_sort: naturalproofs.uct.UCTSort
    :return: z3.ExprRef
    &#34;&#34;&#34;
    # TODO: typecheck all the arguments
    if uct_sort in {fgsort, intsort}:
        return z3.IntVal(value)
    elif uct_sort == boolsort:
        return z3.BoolVal(value)
    elif uct_sort in {fgsetsort, intsetsort}:
        expr = z3.EmptySet(z3.IntSort())
        for elem in value:
            expr = z3.SetAdd(expr, z3.IntVal(elem))
    else:
        raise ValueError(&#39;Sort not supported. Check for a list of available sorts in the naturalproofs.uct module.&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="extensions.finitemodel.model_key_repr"><code class="name flex">
<span>def <span class="ident">model_key_repr</span></span>(<span>funcdeclref)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_key_repr(funcdeclref):
    # Should be equivalent to naturalproofs.AnnotatedContext._alias_annotation_key_repr(funcdeclref)
    # For z3.FuncDeclRef objects, this is almost always equal to name()
    return funcdeclref.name()</code></pre>
</details>
</dd>
<dt id="extensions.finitemodel.recover_value"><code class="name flex">
<span>def <span class="ident">recover_value</span></span>(<span>value, uct_sort)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverse of _extract_value. Given a pythonic value, returns a z3 embedding of it depending on its uct sort. The
explicit embedding scheme is as follows:
fgsort -&gt; z3.ArithRef
fgsetsort -&gt; z3.ArrayRef
intsort -&gt; z3.ArithRef
intsetsort -&gt; z3.ArrayRef
boolsort -&gt; z3.BoolRef
:param value: any
:param uct_sort: naturalproofs.uct.UCTSort
:return: z3.ExprRef</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recover_value(value, uct_sort):
    &#34;&#34;&#34;
    Inverse of _extract_value. Given a pythonic value, returns a z3 embedding of it depending on its uct sort. The 
    explicit embedding scheme is as follows:
    fgsort -&gt; z3.ArithRef
    fgsetsort -&gt; z3.ArrayRef
    intsort -&gt; z3.ArithRef
    intsetsort -&gt; z3.ArrayRef
    boolsort -&gt; z3.BoolRef
    :param value: any
    :param uct_sort: naturalproofs.uct.UCTSort
    :return: z3.ExprRef
    &#34;&#34;&#34;
    # TODO: typecheck all the arguments
    if uct_sort in {fgsort, intsort}:
        return z3.IntVal(value)
    elif uct_sort == boolsort:
        return z3.BoolVal(value)
    elif uct_sort in {fgsetsort, intsetsort}:
        expr = z3.EmptySet(z3.IntSort())
        for elem in value:
            expr = z3.SetAdd(expr, z3.IntVal(elem))
    else:
        raise ValueError(&#39;Sort not supported. Check for a list of available sorts in the naturalproofs.uct module.&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="extensions.finitemodel.FiniteModel"><code class="flex name class">
<span>class <span class="ident">FiniteModel</span></span>
<span>(</span><span>smtmodel, terms, vocabulary=None, annctx=&lt;naturalproofs.AnnotatedContext.AnnotatedContext object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Finite model creation.<br>
Foreground universe of extracted model corresponds to terms with subterm-closure. If vocabulary is not
specified, the entire vocabulary tracked in annctx is used.<br>
:param smtmodel: z3.ModelRef<br>
:param terms: set of z3.ExprRef<br>
:param vocabulary: set of z3.ExprRef<br>
:param annctx: naturalproofs.AnnotatedContext.AnnotatedContext
</p>
<p>This function also defines the format of finite models.<br>
Given a vocabulary of functions f1, f2, ..fm, of arity a1, a2, &hellip;am, the model is as follows:<br>
model :: dict {'fk' : dict_fk}<br>
where 'fk' is some representation of the function fk, and<br>
dict_fk :: dict {(e1, e2,&hellip; ek) : fk(e1, e2, &hellip;ek)}<br>
where (e1, e2, &hellip;ek) is a tuple such that e1, e2,.. etc are concrete values in python that are
dependent on the domain and range sorts of fk.<br>
In particular if the arity k is 0, then dict_fk will be of the following form:<br>
dict_fk :: dict {() : fk()}
</p>
<p>These models are meant to be partial models, and in general it will not be possible to evaluate an arbitrary
formula on such a model, just those that are quantifier-free with foreground terms in the set of terms used
to extract the finite model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FiniteModel:
    def __init__(self, smtmodel, terms, vocabulary=None, annctx=default_annctx):
        &#34;&#34;&#34;
        Finite model creation.  
        Foreground universe of extracted model corresponds to terms with subterm-closure. If vocabulary is not 
        specified, the entire vocabulary tracked in annctx is used.  
        :param smtmodel: z3.ModelRef  
        :param terms: set of z3.ExprRef  
        :param vocabulary: set of z3.ExprRef  
        :param annctx: naturalproofs.AnnotatedContext.AnnotatedContext  

        This function also defines the format of finite models.  
        Given a vocabulary of functions f1, f2, ..fm, of arity a1, a2, ...am, the model is as follows:  
        model :: dict {&#39;fk&#39; : dict_fk}  
        where &#39;fk&#39; is some representation of the function fk, and  
        dict_fk :: dict {(e1, e2,... ek) : fk(e1, e2, ...ek)}  
        where (e1, e2, ...ek) is a tuple such that e1, e2,.. etc are concrete values in python that are 
        dependent on the domain and range sorts of fk.  
        In particular if the arity k is 0, then dict_fk will be of the following form:  
        dict_fk :: dict {() : fk()}  

        These models are meant to be partial models, and in general it will not be possible to evaluate an arbitrary
        formula on such a model, just those that are quantifier-free with foreground terms in the set of terms used 
        to extract the finite model.  
        &#34;&#34;&#34;
        model = dict()
        # TODO: the assumption is that uninterpreted functions have arguments only from the foreground sort. Must handle
        #  cases where uninterpreted functions have arguments in other domains, primarily integers.
        # Subterm-close the given terms assuming one-way functions
        # TODO: checks for all terms being of the foreground sort.
        subterm_closure = _get_all_subterms(terms)
        elems = {smtmodel.eval(term, model_completion=True) for term in subterm_closure}
        if vocabulary is None:
            vocabulary = get_vocabulary(annctx)
        for func in vocabulary:
            arity = func.arity()
            *input_signature, output_sort = get_uct_signature(func, annctx)
            # Only supporting uninterpreted functions with input arguments all from the foreground sort
            if not all(sig == fgsort for sig in input_signature):
                raise ValueError(&#39;Function with input(s) not from the foreground sort. Unsupported.&#39;)
            func_key_repr = model_key_repr(func)
            # Distinguish common cases for faster execution
            if arity == 0:
                model[func_key_repr] = {(): _extract_value(smtmodel.eval(func(), model_completion=True), output_sort)}
            elif arity == 1:
                model[func_key_repr] = {
                    (_extract_value(elem, fgsort),): _extract_value(smtmodel.eval(func(elem), model_completion=True),
                                                                    output_sort) for elem in elems}
            else:
                func_dict = dict()
                args = itertools.product(elems, repeat=arity)
                for arg in args:
                    arg_value = tuple(_extract_value(component, fgsort) for component in arg)
                    func_dict[arg_value] = _extract_value(smtmodel.eval(func(*arg), model_completion=True), output_sort)
                model[func_key_repr] = func_dict
        # Object attributes
        self.finitemodel = model
        self.smtmodel = smtmodel
        self.vocabulary = vocabulary
        self.annctx = annctx
        self.offset = 0
        self.fg_universe = collect_fg_universe(self.finitemodel, self.annctx)
        # Logging attributes
        self.extraction_terms = subterm_closure
        # Caching attributes
        self.recompute_offset = True

    # Some common functions on finite models
    def get_fg_elements(self):
        # fg_elem_set = set()
        # _ = transform_fg_universe(finite_model, lambda x: (fg_elem_set.add(x), x)[1], annctx)
        # return fg_elem_set
        return self.fg_universe

    def add_fg_element_offset(self, offset_value):
        if self.recompute_offset:
            self.finitemodel = transform_fg_universe(self.finitemodel, lambda x: x + offset_value, self.annctx)
            self.offset = self.offset + offset_value
            self.fg_universe = {elem + offset_value for elem in self.fg_universe}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="extensions.finitemodel.FiniteModel.add_fg_element_offset"><code class="name flex">
<span>def <span class="ident">add_fg_element_offset</span></span>(<span>self, offset_value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_fg_element_offset(self, offset_value):
    if self.recompute_offset:
        self.finitemodel = transform_fg_universe(self.finitemodel, lambda x: x + offset_value, self.annctx)
        self.offset = self.offset + offset_value
        self.fg_universe = {elem + offset_value for elem in self.fg_universe}</code></pre>
</details>
</dd>
<dt id="extensions.finitemodel.FiniteModel.get_fg_elements"><code class="name flex">
<span>def <span class="ident">get_fg_elements</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fg_elements(self):
    # fg_elem_set = set()
    # _ = transform_fg_universe(finite_model, lambda x: (fg_elem_set.add(x), x)[1], annctx)
    # return fg_elem_set
    return self.fg_universe</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="extensions" href="index.html">extensions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="extensions.finitemodel.model_key_repr" href="#extensions.finitemodel.model_key_repr">model_key_repr</a></code></li>
<li><code><a title="extensions.finitemodel.recover_value" href="#extensions.finitemodel.recover_value">recover_value</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="extensions.finitemodel.FiniteModel" href="#extensions.finitemodel.FiniteModel">FiniteModel</a></code></h4>
<ul class="">
<li><code><a title="extensions.finitemodel.FiniteModel.add_fg_element_offset" href="#extensions.finitemodel.FiniteModel.add_fg_element_offset">add_fg_element_offset</a></code></li>
<li><code><a title="extensions.finitemodel.FiniteModel.get_fg_elements" href="#extensions.finitemodel.FiniteModel.get_fg_elements">get_fg_elements</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>